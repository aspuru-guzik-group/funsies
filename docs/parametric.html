<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>funsies.parametric API documentation</title>
<meta name="description" content="User-facing functions for parametric DAGs." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>funsies.parametric</code></h1>
</header>
<section id="section-intro">
<p>User-facing functions for parametric DAGs.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;User-facing functions for parametric DAGs.&#34;&#34;&#34;
from __future__ import annotations

# std
from typing import Any, Optional

# external
from redis import Redis

# module
from ._constants import hash_t
from ._context import get_db
from ._graph import Artefact
from ._parametrize import make_parametric, Parametric
from .ui import _Target, put


def commit(
    name: str,
    inp: dict[str, Artefact[Any]],
    out: dict[str, Artefact[Any]],
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; hash_t:
    &#34;&#34;&#34;Parametrize and commit a workflow.

    This function gives a name to part of a workflow and parametrizes it for
    use with `parametric.recall`. This is probably best described by an
    example,

    ```
    import funsies as f

    name_john = f.put(&#34;john&#34;)
    name_John = f.morph(lambda x: x.capitalize(), name)
    f.parametric.commit(
        &#34;capitalize&#34;,
        in={&#34;name&#34;:name_john},
        out={&#34;name_out&#34;:name_John}
    )
    ```

    Now say we wanted to capitalize other names, we can recall the
    `&#34;capitalize&#34;` workflow with new input parameters,

    ```
    out = f.parametric.recall(&#34;capitalize&#34;, {&#34;name&#34;:&#34;tim&#34;})
    f.execute(out[&#34;name_out&#34;])
    f.take(out[&#34;name_out&#34;])     # returns &#34;Tim&#34;
    ```

    These parametric workflows can be used across scripts, machines, etc. They
    allow encoding steps that can be reproduced without access to the original
    workflow script.

    The graph of task from `inp` to `out` artefacts (and any depedencies) is
    what is saved by `parametric.commit()`.

    Specifically, the `inp` and `out` artefacts defines the workflow to
    encode. Only those input artefacts that will need to be modified on
    `parametric.recall()` need to be explicitly passed. Only those output
    artefacts that we would like computed needs to be passed in `out`. Any
    other necessary inputs will be loaded from the artefact store but not
    parametrized, that is, with the values they had at the time of
    `parametric.commit()`.

    Args:
        name: Name of the parametric DAG.
        inp: Dictionary of artefacts that form the inputs to the Parametric DAG.
        out: Dictionary of artefacts that form the outputs to the Parametric
            DAG. `inp` and `out` together define the committed DAG.
        connection: An explicit Redis connection. Not required if called within a
            `Fun()` context.

    Returns:
        The hash value of the committed Parametric DAG.
    &#34;&#34;&#34;
    db = get_db(connection)
    param = make_parametric(db, name, inp, out)
    return param.hash


def recall(
    name_or_hash: str,
    inp: dict[str, _Target],
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; dict[str, Artefact[Any]]:
    &#34;&#34;&#34;Recall a Parametric DAG and evaluate it.

    This function recalls a workflow previously encoded with
    `parametric.commit()`, substitutes in the values in `inp` and returns a
    dictionary of artefacts (from `out` in `parametric.commit()`) that
    descends from the new input values.

    Note that every step is automatically duplicated to account for new data
    if and only if doing so is necessary. That is, the calculation is
    incremental.

    Args:
        name_or_hash: Name or hash value of a DAG encoded with `parametric.commit()`.
        inp: Dictionary of artefacts corresponding to those passed to
            `parametric.commit()`. Any omitted data will simply be substituted by
            whatever was committed.
        connection: An explicit Redis connection. Not required if called within a
            `Fun()` context.

    Returns:
        A dictionary of artefacts that corresponds to the `out=` argument of
        `parametric.commit()`.
    &#34;&#34;&#34;
    db = get_db(connection)

    # first, check if its a name
    h = Parametric.resolve_name(db, name_or_hash)
    if h is None:
        # Probably a hash then
        h = hash_t(name_or_hash)

    param = Parametric.grab(db, h)
    new_inps = {}
    for k, arg in inp.items():
        if k not in param.inp:
            raise AttributeError(
                f&#34;input {k} to parametric {h} not in defined inputs&#34;
                + f&#34; {list(param.inp.keys())}&#34;
            )
        if isinstance(arg, Artefact):
            new_inps[k] = arg
        else:
            new_inps[k] = put(arg, connection=db)

    # TODO: encoding check?
    # for k, art in new_inps.items():
    #     if art.kind != param.inp[k].kind:
    #         raise TypeError(
    #             f&#34;input {k} to parametric {h} as encoding {art.kind},&#34;
    #             + f&#34; expected {param.inp[k].kind}&#34;
    #         )

    return param.evaluate(db, new_inps)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="funsies.parametric.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>name: str, inp: dict[str, Artefact[Any]], out: dict[str, Artefact[Any]], *, connection: Optional[Redis[bytes]] = None) ‑> hash_t</span>
</code></dt>
<dd>
<div class="desc"><p>Parametrize and commit a workflow.</p>
<p>This function gives a name to part of a workflow and parametrizes it for
use with <code>parametric.recall</code>. This is probably best described by an
example,</p>
<pre><code>import funsies as f

name_john = f.put(&quot;john&quot;)
name_John = f.morph(lambda x: x.capitalize(), name)
f.parametric.commit(
    &quot;capitalize&quot;,
    in={&quot;name&quot;:name_john},
    out={&quot;name_out&quot;:name_John}
)
</code></pre>
<p>Now say we wanted to capitalize other names, we can recall the
<code>"capitalize"</code> workflow with new input parameters,</p>
<pre><code>out = f.parametric.recall(&quot;capitalize&quot;, {&quot;name&quot;:&quot;tim&quot;})
f.execute(out[&quot;name_out&quot;])
f.take(out[&quot;name_out&quot;])     # returns &quot;Tim&quot;
</code></pre>
<p>These parametric workflows can be used across scripts, machines, etc. They
allow encoding steps that can be reproduced without access to the original
workflow script.</p>
<p>The graph of task from <code>inp</code> to <code>out</code> artefacts (and any depedencies) is
what is saved by <code>parametric.commit()</code>.</p>
<p>Specifically, the <code>inp</code> and <code>out</code> artefacts defines the workflow to
encode. Only those input artefacts that will need to be modified on
<code>parametric.recall()</code> need to be explicitly passed. Only those output
artefacts that we would like computed needs to be passed in <code>out</code>. Any
other necessary inputs will be loaded from the artefact store but not
parametrized, that is, with the values they had at the time of
<code>parametric.commit()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong></dt>
<dd>Name of the parametric DAG.</dd>
<dt><strong><code>inp</code></strong></dt>
<dd>Dictionary of artefacts that form the inputs to the Parametric DAG.</dd>
<dt><strong><code>out</code></strong></dt>
<dd>Dictionary of artefacts that form the outputs to the Parametric
DAG. <code>inp</code> and <code>out</code> together define the committed DAG.</dd>
<dt><strong><code>connection</code></strong></dt>
<dd>An explicit Redis connection. Not required if called within a
<code>Fun()</code> context.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The hash value of the committed Parametric DAG.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(
    name: str,
    inp: dict[str, Artefact[Any]],
    out: dict[str, Artefact[Any]],
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; hash_t:
    &#34;&#34;&#34;Parametrize and commit a workflow.

    This function gives a name to part of a workflow and parametrizes it for
    use with `parametric.recall`. This is probably best described by an
    example,

    ```
    import funsies as f

    name_john = f.put(&#34;john&#34;)
    name_John = f.morph(lambda x: x.capitalize(), name)
    f.parametric.commit(
        &#34;capitalize&#34;,
        in={&#34;name&#34;:name_john},
        out={&#34;name_out&#34;:name_John}
    )
    ```

    Now say we wanted to capitalize other names, we can recall the
    `&#34;capitalize&#34;` workflow with new input parameters,

    ```
    out = f.parametric.recall(&#34;capitalize&#34;, {&#34;name&#34;:&#34;tim&#34;})
    f.execute(out[&#34;name_out&#34;])
    f.take(out[&#34;name_out&#34;])     # returns &#34;Tim&#34;
    ```

    These parametric workflows can be used across scripts, machines, etc. They
    allow encoding steps that can be reproduced without access to the original
    workflow script.

    The graph of task from `inp` to `out` artefacts (and any depedencies) is
    what is saved by `parametric.commit()`.

    Specifically, the `inp` and `out` artefacts defines the workflow to
    encode. Only those input artefacts that will need to be modified on
    `parametric.recall()` need to be explicitly passed. Only those output
    artefacts that we would like computed needs to be passed in `out`. Any
    other necessary inputs will be loaded from the artefact store but not
    parametrized, that is, with the values they had at the time of
    `parametric.commit()`.

    Args:
        name: Name of the parametric DAG.
        inp: Dictionary of artefacts that form the inputs to the Parametric DAG.
        out: Dictionary of artefacts that form the outputs to the Parametric
            DAG. `inp` and `out` together define the committed DAG.
        connection: An explicit Redis connection. Not required if called within a
            `Fun()` context.

    Returns:
        The hash value of the committed Parametric DAG.
    &#34;&#34;&#34;
    db = get_db(connection)
    param = make_parametric(db, name, inp, out)
    return param.hash</code></pre>
</details>
</dd>
<dt id="funsies.parametric.recall"><code class="name flex">
<span>def <span class="ident">recall</span></span>(<span>name_or_hash: str, inp: dict[str, _Target], *, connection: Optional[Redis[bytes]] = None) ‑> dict[str, Artefact[Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Recall a Parametric DAG and evaluate it.</p>
<p>This function recalls a workflow previously encoded with
<code>parametric.commit()</code>, substitutes in the values in <code>inp</code> and returns a
dictionary of artefacts (from <code>out</code> in <code>parametric.commit()</code>) that
descends from the new input values.</p>
<p>Note that every step is automatically duplicated to account for new data
if and only if doing so is necessary. That is, the calculation is
incremental.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name_or_hash</code></strong></dt>
<dd>Name or hash value of a DAG encoded with <code>parametric.commit()</code>.</dd>
<dt><strong><code>inp</code></strong></dt>
<dd>Dictionary of artefacts corresponding to those passed to
<code>parametric.commit()</code>. Any omitted data will simply be substituted by
whatever was committed.</dd>
<dt><strong><code>connection</code></strong></dt>
<dd>An explicit Redis connection. Not required if called within a
<code>Fun()</code> context.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary of artefacts that corresponds to the <code>out=</code> argument of
<code>parametric.commit()</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recall(
    name_or_hash: str,
    inp: dict[str, _Target],
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; dict[str, Artefact[Any]]:
    &#34;&#34;&#34;Recall a Parametric DAG and evaluate it.

    This function recalls a workflow previously encoded with
    `parametric.commit()`, substitutes in the values in `inp` and returns a
    dictionary of artefacts (from `out` in `parametric.commit()`) that
    descends from the new input values.

    Note that every step is automatically duplicated to account for new data
    if and only if doing so is necessary. That is, the calculation is
    incremental.

    Args:
        name_or_hash: Name or hash value of a DAG encoded with `parametric.commit()`.
        inp: Dictionary of artefacts corresponding to those passed to
            `parametric.commit()`. Any omitted data will simply be substituted by
            whatever was committed.
        connection: An explicit Redis connection. Not required if called within a
            `Fun()` context.

    Returns:
        A dictionary of artefacts that corresponds to the `out=` argument of
        `parametric.commit()`.
    &#34;&#34;&#34;
    db = get_db(connection)

    # first, check if its a name
    h = Parametric.resolve_name(db, name_or_hash)
    if h is None:
        # Probably a hash then
        h = hash_t(name_or_hash)

    param = Parametric.grab(db, h)
    new_inps = {}
    for k, arg in inp.items():
        if k not in param.inp:
            raise AttributeError(
                f&#34;input {k} to parametric {h} not in defined inputs&#34;
                + f&#34; {list(param.inp.keys())}&#34;
            )
        if isinstance(arg, Artefact):
            new_inps[k] = arg
        else:
            new_inps[k] = put(arg, connection=db)

    # TODO: encoding check?
    # for k, art in new_inps.items():
    #     if art.kind != param.inp[k].kind:
    #         raise TypeError(
    #             f&#34;input {k} to parametric {h} as encoding {art.kind},&#34;
    #             + f&#34; expected {param.inp[k].kind}&#34;
    #         )

    return param.evaluate(db, new_inps)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="funsies" href="index.html">funsies</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="funsies.parametric.commit" href="#funsies.parametric.commit">commit</a></code></li>
<li><code><a title="funsies.parametric.recall" href="#funsies.parametric.recall">recall</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>