<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>funsies.ui API documentation</title>
<meta name="description" content="User-friendly interfaces to funsies functionality." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>funsies.ui</code></h1>
</header>
<section id="section-intro">
<p>User-friendly interfaces to funsies functionality.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;User-friendly interfaces to funsies functionality.&#34;&#34;&#34;
from __future__ import annotations

# std
import time
from typing import Iterable, Mapping, Optional, overload, TypeVar, Union

# external
from redis import Redis

# python 3.7 imports Literal from typing_extensions
try:
    # std
    from typing import Literal
except ImportError:
    from typing_extensions import Literal  # type:ignore

# module
from ._constants import _AnyPath, _Data, hash_t
from ._context import get_db, get_options
from ._dag import descendants, start_dag_execution
from ._graph import (
    Artefact,
    constant_artefact,
    delete_artefact,
    get_bytes,
    get_data,
    get_status,
    make_op,
    Operation,
    resolve_link,
)
from ._logging import logger
from ._run import is_it_cached
from ._shell import shell_funsie, ShellOutput
from ._short_hash import shorten_hash
from .config import Options
from .errors import Error, Result, unwrap

# Types
_Target = Union[Artefact, _Data]
_INP_FILES = Optional[Mapping[_AnyPath, _Target]]
_OUT_FILES = Optional[Iterable[_AnyPath]]
T = TypeVar(&#34;T&#34;, bound=_Data)


def _artefact(db: Redis[bytes], data: Union[T, Artefact[T]]) -&gt; Artefact[T]:
    if isinstance(data, Artefact):
        return data
    else:
        return constant_artefact(db, data)


# --------------------------------------------------------------------------------
# Dag execution
def execute(
    *outputs: Union[Operation, Artefact, ShellOutput],
    connection: Optional[Redis[bytes]] = None,
) -&gt; None:
    &#34;&#34;&#34;Trigger execution of a workflow to obtain a given output.

    Args:
        *outputs: Final artefacts or operations to be evaluated in the
            workflow. These objects and all of their dependencies will be
            executed by workers.
        connection: An explicit Redis connection. Not required if called
            within a `Fun()` context.
    &#34;&#34;&#34;
    # get redis
    db = get_db(connection)

    # run dag
    for el in outputs:
        start_dag_execution(db, el.hash)


# --------------------------------------------------------------------------------
# Shell command
def shell(
    *args: str,
    inp: _INP_FILES = None,
    out: _OUT_FILES = None,
    env: Optional[dict[str, str]] = None,
    strict: bool = True,
    opt: Optional[Options] = None,
    connection: Optional[Redis[bytes]] = None,
) -&gt; ShellOutput:
    &#34;&#34;&#34;Add a shell command to the workflow.

    `shell()` puts a shell command in the workflow and returns a `types.ShellOutput`
    instance that provides a convenient wrapper to stdout, stderr and output
    files.

    Input and output files need to be explicitly given as arguments `inp` and
    `out`. Input and output files containing path separators (`/`) are assumed
    to belong to the corresponding directory tree structures, which will be
    automatically generated for input files.

    The `strict` flag determines how to interpret errors in input files. If
    `True` (the default), errors are propagated down: shell commands will not
    be executed if any input values currently hold `errors.Error`. Instead, all
    output values will also be replaced by `errors.Error`.

    When `strict=False`, input files with errors will simply (and silently) be
    excluded from the shell script.

    Shell commands are run in a temporary directory which conveys some measure
    of encapsulation, but it is quite weak, so the callee should make sure
    that commands only use relative paths etc. to ensure proper cleanup and
    function purity. This is done using python&#39;s `tempfile` module: the temporary
    directory can be set using the $TMPDIR environment variable.

    Environment variables can be passed to the executed command with the
    `env=` keyword. In contrast with `subprocess.Popen()`, the environment of
    worker processes will be updated with those values, *not* replaced by
    them. Environment variables are not hashed as part of the operation&#39;s id
    and thus changing them will not result in workflow re-execution.

    Args:
        *args: Lines of shell script to be evaluated.
        inp: Input files to pass to the shell comand. This should be a Mapping
            from filenames (str, path etc.) to values. Values can either be
            `types.Artefact` instances or of type `bytes`, in which case they
            will be automatically converted using `put()`.
        out: Filenames of output files that will be used to populate the return
            `types.ShellOutput` object. Note that any file not included in
            this list will be deleted when the shell command terminates.
        env: Environment variables to be set before calling the shell command.
        strict: If `False`, error handling will be deferred to the shell command
            by not populating input files of type `Error`.
        connection: An explicit Redis connection. Not required if called within a
            `Fun()` context.
        opt: An `types.Options` instance as returned by `options()`. Not
            required if called within a `Fun()` context.

    Returns:
        A `types.ShellOutput` object, populated with the generated
        `types.Artefact` instances.

    Raises:
        TypeError: when types of arguments are wrong.

    &#34;&#34;&#34;
    opt = get_options(opt)
    db = get_db(connection)

    # Parse args --------------------------------------------
    cmds: list[str] = []
    inputs: dict[str, Artefact] = {}

    for arg in args:
        if isinstance(arg, str):
            cmds += [arg]
        else:
            raise TypeError(f&#34;argument {arg} not str.&#34;)

    # Parse input files -------------------------------------
    if inp is None:
        pass
    # multiple input files as a mapping
    elif isinstance(inp, Mapping):
        for key, val in inp.items():
            if isinstance(val, str):
                logger.warning(
                    f&#34;{key} passed to shell as a string.\nif you don&#39;t want it to be&#34;
                    + &#39; converted to json (and wrapped with &#34;), \nyou NEED to pass it&#39;
                    + &#34; as bytes (by .encode()-ing it first)&#34;
                )
            inputs[str(key)] = _artefact(db, val)
    else:
        raise TypeError(f&#34;{inp} not a valid file input&#34;)

    if out is None:
        outputs = []
    else:
        outputs = [str(o) for o in out]

    inputs_types = dict([(k, v.kind) for k, v in inputs.items()])
    funsie = shell_funsie(cmds, inputs_types, outputs, env, strict=strict)
    operation = make_op(db, funsie, inputs, opt)
    return ShellOutput(db, operation)


# --------------------------------------------------------------------------------
# Data loading and saving
def put(
    value: T,
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; Artefact[T]:
    &#34;&#34;&#34;Save data to Redis and return an Artefact.

    `put()` explicitly saves `value`, a bytes or string value, to the database
    and return an `types.Artefact` pointing to this value.

    The returned artefact&#39;s status is `types.ArtefactStatus.const` and its
    parent hash is `root`. This means that:

    - The arterfact is populated before any workflow operation is executed.
    - It has no dependencies
    - It is hashed according to content, not history.

    Thus, `put()` is used to set input values to workflows.

    Args:
        value: Data to be held in database. `str` data is encoded to `bytes`.
        connection (optional): An explicit Redis connection. Not required if
            called within a `Fun()` context.

    Returns:
        An `types.Artefact` instance with status `const`.
    &#34;&#34;&#34;
    db = get_db(connection)
    return _artefact(db, value)


def __log_error(where: hash_t, dat: Result[object]) -&gt; None:
    if isinstance(dat, Error):
        logger.warning(f&#34;data error at hash {shorten_hash(where)}&#34;)


# fmt:off
@overload
def take(where: Artefact[T], *, strict: Literal[True] = True, connection: Optional[Redis[bytes]]=None) -&gt; T:  # noqa
    ...


@overload
def take(where: Artefact[T], *, strict: Literal[False] = False, connection: Optional[Redis[bytes]]=None) -&gt; Result[T]:  # noqa
    ...
# fmt:on


def take(
    where: Artefact[T],
    *,
    strict: bool = True,
    connection: Optional[Redis[bytes]] = None,
) -&gt; Union[T, Result[T]]:
    &#34;&#34;&#34;Take data corresponding to a given artefact from Redis.

    `take()` returns the currently held value of pointed to by the
    `types.Artefact` instance `where` as `bytes`.

    If `strict=True` (the default) and `where` points to an `types.Error`
    value, this function will raise `errors.UnwrapError`. This is equivalent
    to running `unwrap()` on the return value.

    However if `strict=False`, the return value of `take()` is a
    `errors.Result[bytes]` variable, that is, either an instance of `bytes` or
    whatever `types.Error` is currently held by `where`.

    Finally, if `where` does not point to a valid redis-backed
    `types.Artefact` an `errors.Error` is returned of kind
    `errors.ErrorKind.Mismatch`.

    Args:
        where: `types.Artefact` pointer to data taken from the database.
        strict: If `False`, return a value of type `errors.Result[bytes]`.
        connection: An explicit Redis connection. Not required if called
            within a `Fun()` context.

    Returns:
        Either `bytes` or `errors.Result[bytes]` depending on strictness.

    Raises:
        errors.UnwrapError:
            if `where` contains an `errors.Error` and `strict=True`.

    &#34;&#34;&#34;
    db = get_db(connection)
    dat = get_data(db, where)
    __log_error(where.hash, dat)
    if strict:
        return unwrap(dat)
    else:
        return dat


def takeout(
    where: Artefact,
    filename: _AnyPath,
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; None:  # noqa:DAR101,DAR201
    &#34;&#34;&#34;`take()` an artefact and save it to `filename`.

    This is syntactic sugar around `take()`. This function is always strict.
    &#34;&#34;&#34;
    db = get_db(connection)
    dat = get_bytes(db, where)
    __log_error(where.hash, dat)
    dat = unwrap(dat)
    with open(filename, &#34;wb&#34;) as f:
        f.write(dat)


def wait_for(
    thing: Union[ShellOutput, Artefact, Operation],
    timeout: Optional[float] = None,
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; None:
    &#34;&#34;&#34;Block execution until an artefact is generated or an operation is executed.

    Args:
        thing: `types.Artefact` or operation to wait on.
        timeout (optional): Number of seconds to wait for before raising an
            exception. If unspecified, timeout is taken to be infinite.
        connection (optional): An explicit Redis connection. Not required if
            called within a `Fun()` context.

    Raises:
        TimeoutError: if timeout is exceeded.
    &#34;&#34;&#34;
    db = get_db(connection)
    if isinstance(thing, Artefact):

        def __stat() -&gt; bool:
            return get_status(db, resolve_link(db, thing.hash)) &gt; 0

    else:
        if isinstance(thing, Operation):
            op = thing
        else:
            op = thing.op

        def __stat() -&gt; bool:
            return is_it_cached(db, op)

    t0 = time.time()
    while True:
        t1 = time.time()

        if __stat():
            return

        if timeout is not None:
            if t1 - t0 &gt; timeout:
                raise TimeoutError(
                    f&#34;waited on {shorten_hash(thing.hash)} &#34; + f&#34;for {t1-t0} seconds.&#34;
                )

        # avoids hitting the DB way too often
        time.sleep(0.3)


def reset(
    thing: Union[ShellOutput, Operation, Artefact],
    *,
    recursive: bool = True,
    connection: Optional[Redis[bytes]] = None,
) -&gt; None:
    &#34;&#34;&#34;Reset data associated with an operation and its dependents.

    This function deletes data associated with an operation or the operation
    generating a given artefact without actually removing it from the
    workflow. This is useful if an operation failed due to circumstances
    outside of the control of `funsies`, such as a non-reproducible step or
    worker setup error. When the workflow is executed again, all the `reset()`
    steps will be re-computed.

    By default, `reset()` is applied recursively to all dependents of an
    operation.

    Args:
        thing: Operation to reset. If an `types.Artefact` is given, its parent
            operation is `reset()`.
        recursive: If False, only this operation is reset; its dependents are
            untouched. Note that this is dangerous, as it can make
            non-reproducible workflows.
        connection: An explicit Redis connection. Not required if called
            within a `Fun()` context.

    Raises:
        AttributeError:
            when an `types.Artefact` is reset that has status
            `types.ArtefactStatus.const`.
    &#34;&#34;&#34;
    db = get_db(connection)
    if isinstance(thing, Artefact):
        h = thing.parent
        if h == &#34;root&#34;:
            raise AttributeError(&#34;attempted to delete a const artefact.&#34;)
    else:
        h = thing.hash

    # Delete everything from the operation
    op = Operation.grab(db, h)
    for art in op.out.values():
        delete_artefact(db, art)

    if recursive:
        # and its dependencies
        for el in descendants(db, h):
            op = Operation.grab(db, el)
            for art in op.out.values():
                delete_artefact(db, art)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="funsies.ui.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>*outputs: Union[Operation, Artefact, ShellOutput], connection: Optional[Redis[bytes]] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Trigger execution of a workflow to obtain a given output.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*outputs</code></strong></dt>
<dd>Final artefacts or operations to be evaluated in the
workflow. These objects and all of their dependencies will be
executed by workers.</dd>
<dt><strong><code>connection</code></strong></dt>
<dd>An explicit Redis connection. Not required if called
within a <code>Fun()</code> context.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(
    *outputs: Union[Operation, Artefact, ShellOutput],
    connection: Optional[Redis[bytes]] = None,
) -&gt; None:
    &#34;&#34;&#34;Trigger execution of a workflow to obtain a given output.

    Args:
        *outputs: Final artefacts or operations to be evaluated in the
            workflow. These objects and all of their dependencies will be
            executed by workers.
        connection: An explicit Redis connection. Not required if called
            within a `Fun()` context.
    &#34;&#34;&#34;
    # get redis
    db = get_db(connection)

    # run dag
    for el in outputs:
        start_dag_execution(db, el.hash)</code></pre>
</details>
</dd>
<dt id="funsies.ui.shell"><code class="name flex">
<span>def <span class="ident">shell</span></span>(<span>*args: str, inp: _INP_FILES = None, out: _OUT_FILES = None, env: Optional[dict[str, str]] = None, strict: bool = True, opt: Optional[Options] = None, connection: Optional[Redis[bytes]] = None) ‑> ShellOutput</span>
</code></dt>
<dd>
<div class="desc"><p>Add a shell command to the workflow.</p>
<p><code><a title="funsies.ui.shell" href="#funsies.ui.shell">shell()</a></code> puts a shell command in the workflow and returns a <code>types.ShellOutput</code>
instance that provides a convenient wrapper to stdout, stderr and output
files.</p>
<p>Input and output files need to be explicitly given as arguments <code>inp</code> and
<code>out</code>. Input and output files containing path separators (<code>/</code>) are assumed
to belong to the corresponding directory tree structures, which will be
automatically generated for input files.</p>
<p>The <code>strict</code> flag determines how to interpret errors in input files. If
<code>True</code> (the default), errors are propagated down: shell commands will not
be executed if any input values currently hold <code>errors.Error</code>. Instead, all
output values will also be replaced by <code>errors.Error</code>.</p>
<p>When <code>strict=False</code>, input files with errors will simply (and silently) be
excluded from the shell script.</p>
<p>Shell commands are run in a temporary directory which conveys some measure
of encapsulation, but it is quite weak, so the callee should make sure
that commands only use relative paths etc. to ensure proper cleanup and
function purity. This is done using python's <code>tempfile</code> module: the temporary
directory can be set using the $TMPDIR environment variable.</p>
<p>Environment variables can be passed to the executed command with the
<code>env=</code> keyword. In contrast with <code>subprocess.Popen()</code>, the environment of
worker processes will be updated with those values, <em>not</em> replaced by
them. Environment variables are not hashed as part of the operation's id
and thus changing them will not result in workflow re-execution.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>*args</code></strong></dt>
<dd>Lines of shell script to be evaluated.</dd>
<dt><strong><code>inp</code></strong></dt>
<dd>Input files to pass to the shell comand. This should be a Mapping
from filenames (str, path etc.) to values. Values can either be
<code>types.Artefact</code> instances or of type <code>bytes</code>, in which case they
will be automatically converted using <code><a title="funsies.ui.put" href="#funsies.ui.put">put()</a></code>.</dd>
<dt><strong><code>out</code></strong></dt>
<dd>Filenames of output files that will be used to populate the return
<code>types.ShellOutput</code> object. Note that any file not included in
this list will be deleted when the shell command terminates.</dd>
<dt><strong><code>env</code></strong></dt>
<dd>Environment variables to be set before calling the shell command.</dd>
<dt><strong><code>strict</code></strong></dt>
<dd>If <code>False</code>, error handling will be deferred to the shell command
by not populating input files of type <code>Error</code>.</dd>
<dt><strong><code>connection</code></strong></dt>
<dd>An explicit Redis connection. Not required if called within a
<code>Fun()</code> context.</dd>
<dt><strong><code>opt</code></strong></dt>
<dd>An <code>types.Options</code> instance as returned by <code>options()</code>. Not
required if called within a <code>Fun()</code> context.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A <code>types.ShellOutput</code> object, populated with the generated
<code>types.Artefact</code> instances.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>when types of arguments are wrong.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shell(
    *args: str,
    inp: _INP_FILES = None,
    out: _OUT_FILES = None,
    env: Optional[dict[str, str]] = None,
    strict: bool = True,
    opt: Optional[Options] = None,
    connection: Optional[Redis[bytes]] = None,
) -&gt; ShellOutput:
    &#34;&#34;&#34;Add a shell command to the workflow.

    `shell()` puts a shell command in the workflow and returns a `types.ShellOutput`
    instance that provides a convenient wrapper to stdout, stderr and output
    files.

    Input and output files need to be explicitly given as arguments `inp` and
    `out`. Input and output files containing path separators (`/`) are assumed
    to belong to the corresponding directory tree structures, which will be
    automatically generated for input files.

    The `strict` flag determines how to interpret errors in input files. If
    `True` (the default), errors are propagated down: shell commands will not
    be executed if any input values currently hold `errors.Error`. Instead, all
    output values will also be replaced by `errors.Error`.

    When `strict=False`, input files with errors will simply (and silently) be
    excluded from the shell script.

    Shell commands are run in a temporary directory which conveys some measure
    of encapsulation, but it is quite weak, so the callee should make sure
    that commands only use relative paths etc. to ensure proper cleanup and
    function purity. This is done using python&#39;s `tempfile` module: the temporary
    directory can be set using the $TMPDIR environment variable.

    Environment variables can be passed to the executed command with the
    `env=` keyword. In contrast with `subprocess.Popen()`, the environment of
    worker processes will be updated with those values, *not* replaced by
    them. Environment variables are not hashed as part of the operation&#39;s id
    and thus changing them will not result in workflow re-execution.

    Args:
        *args: Lines of shell script to be evaluated.
        inp: Input files to pass to the shell comand. This should be a Mapping
            from filenames (str, path etc.) to values. Values can either be
            `types.Artefact` instances or of type `bytes`, in which case they
            will be automatically converted using `put()`.
        out: Filenames of output files that will be used to populate the return
            `types.ShellOutput` object. Note that any file not included in
            this list will be deleted when the shell command terminates.
        env: Environment variables to be set before calling the shell command.
        strict: If `False`, error handling will be deferred to the shell command
            by not populating input files of type `Error`.
        connection: An explicit Redis connection. Not required if called within a
            `Fun()` context.
        opt: An `types.Options` instance as returned by `options()`. Not
            required if called within a `Fun()` context.

    Returns:
        A `types.ShellOutput` object, populated with the generated
        `types.Artefact` instances.

    Raises:
        TypeError: when types of arguments are wrong.

    &#34;&#34;&#34;
    opt = get_options(opt)
    db = get_db(connection)

    # Parse args --------------------------------------------
    cmds: list[str] = []
    inputs: dict[str, Artefact] = {}

    for arg in args:
        if isinstance(arg, str):
            cmds += [arg]
        else:
            raise TypeError(f&#34;argument {arg} not str.&#34;)

    # Parse input files -------------------------------------
    if inp is None:
        pass
    # multiple input files as a mapping
    elif isinstance(inp, Mapping):
        for key, val in inp.items():
            if isinstance(val, str):
                logger.warning(
                    f&#34;{key} passed to shell as a string.\nif you don&#39;t want it to be&#34;
                    + &#39; converted to json (and wrapped with &#34;), \nyou NEED to pass it&#39;
                    + &#34; as bytes (by .encode()-ing it first)&#34;
                )
            inputs[str(key)] = _artefact(db, val)
    else:
        raise TypeError(f&#34;{inp} not a valid file input&#34;)

    if out is None:
        outputs = []
    else:
        outputs = [str(o) for o in out]

    inputs_types = dict([(k, v.kind) for k, v in inputs.items()])
    funsie = shell_funsie(cmds, inputs_types, outputs, env, strict=strict)
    operation = make_op(db, funsie, inputs, opt)
    return ShellOutput(db, operation)</code></pre>
</details>
</dd>
<dt id="funsies.ui.put"><code class="name flex">
<span>def <span class="ident">put</span></span>(<span>value: T, *, connection: Optional[Redis[bytes]] = None) ‑> Artefact[T]</span>
</code></dt>
<dd>
<div class="desc"><p>Save data to Redis and return an Artefact.</p>
<p><code><a title="funsies.ui.put" href="#funsies.ui.put">put()</a></code> explicitly saves <code>value</code>, a bytes or string value, to the database
and return an <code>types.Artefact</code> pointing to this value.</p>
<p>The returned artefact's status is <code>types.ArtefactStatus.const</code> and its
parent hash is <code>root</code>. This means that:</p>
<ul>
<li>The arterfact is populated before any workflow operation is executed.</li>
<li>It has no dependencies</li>
<li>It is hashed according to content, not history.</li>
</ul>
<p>Thus, <code><a title="funsies.ui.put" href="#funsies.ui.put">put()</a></code> is used to set input values to workflows.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>value</code></strong></dt>
<dd>Data to be held in database. <code>str</code> data is encoded to <code>bytes</code>.</dd>
<dt><strong><code>connection</code></strong> :&ensp;<code>optional</code></dt>
<dd>An explicit Redis connection. Not required if
called within a <code>Fun()</code> context.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>An <code>types.Artefact</code> instance with status <code>const</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def put(
    value: T,
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; Artefact[T]:
    &#34;&#34;&#34;Save data to Redis and return an Artefact.

    `put()` explicitly saves `value`, a bytes or string value, to the database
    and return an `types.Artefact` pointing to this value.

    The returned artefact&#39;s status is `types.ArtefactStatus.const` and its
    parent hash is `root`. This means that:

    - The arterfact is populated before any workflow operation is executed.
    - It has no dependencies
    - It is hashed according to content, not history.

    Thus, `put()` is used to set input values to workflows.

    Args:
        value: Data to be held in database. `str` data is encoded to `bytes`.
        connection (optional): An explicit Redis connection. Not required if
            called within a `Fun()` context.

    Returns:
        An `types.Artefact` instance with status `const`.
    &#34;&#34;&#34;
    db = get_db(connection)
    return _artefact(db, value)</code></pre>
</details>
</dd>
<dt id="funsies.ui.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>where: Artefact[T], *, strict: bool = True, connection: Optional[Redis[bytes]] = None) ‑> Union[T, Result[T]]</span>
</code></dt>
<dd>
<div class="desc"><p>Take data corresponding to a given artefact from Redis.</p>
<p><code><a title="funsies.ui.take" href="#funsies.ui.take">take()</a></code> returns the currently held value of pointed to by the
<code>types.Artefact</code> instance <code>where</code> as <code>bytes</code>.</p>
<p>If <code>strict=True</code> (the default) and <code>where</code> points to an <code>types.Error</code>
value, this function will raise <code>errors.UnwrapError</code>. This is equivalent
to running <code>unwrap()</code> on the return value.</p>
<p>However if <code>strict=False</code>, the return value of <code><a title="funsies.ui.take" href="#funsies.ui.take">take()</a></code> is a
<code>errors.Result[bytes]</code> variable, that is, either an instance of <code>bytes</code> or
whatever <code>types.Error</code> is currently held by <code>where</code>.</p>
<p>Finally, if <code>where</code> does not point to a valid redis-backed
<code>types.Artefact</code> an <code>errors.Error</code> is returned of kind
<code>errors.ErrorKind.Mismatch</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>where</code></strong></dt>
<dd><code>types.Artefact</code> pointer to data taken from the database.</dd>
<dt><strong><code>strict</code></strong></dt>
<dd>If <code>False</code>, return a value of type <code>errors.Result[bytes]</code>.</dd>
<dt><strong><code>connection</code></strong></dt>
<dd>An explicit Redis connection. Not required if called
within a <code>Fun()</code> context.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Either <code>bytes</code> or <code>errors.Result[bytes]</code> depending on strictness.</p>
<h2 id="raises">Raises</h2>
<p>errors.UnwrapError:
if <code>where</code> contains an <code>errors.Error</code> and <code>strict=True</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def take(
    where: Artefact[T],
    *,
    strict: bool = True,
    connection: Optional[Redis[bytes]] = None,
) -&gt; Union[T, Result[T]]:
    &#34;&#34;&#34;Take data corresponding to a given artefact from Redis.

    `take()` returns the currently held value of pointed to by the
    `types.Artefact` instance `where` as `bytes`.

    If `strict=True` (the default) and `where` points to an `types.Error`
    value, this function will raise `errors.UnwrapError`. This is equivalent
    to running `unwrap()` on the return value.

    However if `strict=False`, the return value of `take()` is a
    `errors.Result[bytes]` variable, that is, either an instance of `bytes` or
    whatever `types.Error` is currently held by `where`.

    Finally, if `where` does not point to a valid redis-backed
    `types.Artefact` an `errors.Error` is returned of kind
    `errors.ErrorKind.Mismatch`.

    Args:
        where: `types.Artefact` pointer to data taken from the database.
        strict: If `False`, return a value of type `errors.Result[bytes]`.
        connection: An explicit Redis connection. Not required if called
            within a `Fun()` context.

    Returns:
        Either `bytes` or `errors.Result[bytes]` depending on strictness.

    Raises:
        errors.UnwrapError:
            if `where` contains an `errors.Error` and `strict=True`.

    &#34;&#34;&#34;
    db = get_db(connection)
    dat = get_data(db, where)
    __log_error(where.hash, dat)
    if strict:
        return unwrap(dat)
    else:
        return dat</code></pre>
</details>
</dd>
<dt id="funsies.ui.takeout"><code class="name flex">
<span>def <span class="ident">takeout</span></span>(<span>where: Artefact, filename: _AnyPath, *, connection: Optional[Redis[bytes]] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p><code><a title="funsies.ui.take" href="#funsies.ui.take">take()</a></code> an artefact and save it to <code>filename</code>.</p>
<p>This is syntactic sugar around <code><a title="funsies.ui.take" href="#funsies.ui.take">take()</a></code>. This function is always strict.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def takeout(
    where: Artefact,
    filename: _AnyPath,
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; None:  # noqa:DAR101,DAR201
    &#34;&#34;&#34;`take()` an artefact and save it to `filename`.

    This is syntactic sugar around `take()`. This function is always strict.
    &#34;&#34;&#34;
    db = get_db(connection)
    dat = get_bytes(db, where)
    __log_error(where.hash, dat)
    dat = unwrap(dat)
    with open(filename, &#34;wb&#34;) as f:
        f.write(dat)</code></pre>
</details>
</dd>
<dt id="funsies.ui.wait_for"><code class="name flex">
<span>def <span class="ident">wait_for</span></span>(<span>thing: Union[ShellOutput, Artefact, Operation], timeout: Optional[float] = None, *, connection: Optional[Redis[bytes]] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Block execution until an artefact is generated or an operation is executed.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>thing</code></strong></dt>
<dd><code>types.Artefact</code> or operation to wait on.</dd>
<dt><strong><code>timeout</code></strong> :&ensp;<code>optional</code></dt>
<dd>Number of seconds to wait for before raising an
exception. If unspecified, timeout is taken to be infinite.</dd>
<dt><strong><code>connection</code></strong> :&ensp;<code>optional</code></dt>
<dd>An explicit Redis connection. Not required if
called within a <code>Fun()</code> context.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TimeoutError</code></dt>
<dd>if timeout is exceeded.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wait_for(
    thing: Union[ShellOutput, Artefact, Operation],
    timeout: Optional[float] = None,
    *,
    connection: Optional[Redis[bytes]] = None,
) -&gt; None:
    &#34;&#34;&#34;Block execution until an artefact is generated or an operation is executed.

    Args:
        thing: `types.Artefact` or operation to wait on.
        timeout (optional): Number of seconds to wait for before raising an
            exception. If unspecified, timeout is taken to be infinite.
        connection (optional): An explicit Redis connection. Not required if
            called within a `Fun()` context.

    Raises:
        TimeoutError: if timeout is exceeded.
    &#34;&#34;&#34;
    db = get_db(connection)
    if isinstance(thing, Artefact):

        def __stat() -&gt; bool:
            return get_status(db, resolve_link(db, thing.hash)) &gt; 0

    else:
        if isinstance(thing, Operation):
            op = thing
        else:
            op = thing.op

        def __stat() -&gt; bool:
            return is_it_cached(db, op)

    t0 = time.time()
    while True:
        t1 = time.time()

        if __stat():
            return

        if timeout is not None:
            if t1 - t0 &gt; timeout:
                raise TimeoutError(
                    f&#34;waited on {shorten_hash(thing.hash)} &#34; + f&#34;for {t1-t0} seconds.&#34;
                )

        # avoids hitting the DB way too often
        time.sleep(0.3)</code></pre>
</details>
</dd>
<dt id="funsies.ui.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>thing: Union[ShellOutput, Operation, Artefact], *, recursive: bool = True, connection: Optional[Redis[bytes]] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Reset data associated with an operation and its dependents.</p>
<p>This function deletes data associated with an operation or the operation
generating a given artefact without actually removing it from the
workflow. This is useful if an operation failed due to circumstances
outside of the control of <code><a title="funsies" href="index.html">funsies</a></code>, such as a non-reproducible step or
worker setup error. When the workflow is executed again, all the <code><a title="funsies.ui.reset" href="#funsies.ui.reset">reset()</a></code>
steps will be re-computed.</p>
<p>By default, <code><a title="funsies.ui.reset" href="#funsies.ui.reset">reset()</a></code> is applied recursively to all dependents of an
operation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>thing</code></strong></dt>
<dd>Operation to reset. If an <code>types.Artefact</code> is given, its parent
operation is <code><a title="funsies.ui.reset" href="#funsies.ui.reset">reset()</a></code>.</dd>
<dt><strong><code>recursive</code></strong></dt>
<dd>If False, only this operation is reset; its dependents are
untouched. Note that this is dangerous, as it can make
non-reproducible workflows.</dd>
<dt><strong><code>connection</code></strong></dt>
<dd>An explicit Redis connection. Not required if called
within a <code>Fun()</code> context.</dd>
</dl>
<h2 id="raises">Raises</h2>
<p>AttributeError:
when an <code>types.Artefact</code> is reset that has status
<code>types.ArtefactStatus.const</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(
    thing: Union[ShellOutput, Operation, Artefact],
    *,
    recursive: bool = True,
    connection: Optional[Redis[bytes]] = None,
) -&gt; None:
    &#34;&#34;&#34;Reset data associated with an operation and its dependents.

    This function deletes data associated with an operation or the operation
    generating a given artefact without actually removing it from the
    workflow. This is useful if an operation failed due to circumstances
    outside of the control of `funsies`, such as a non-reproducible step or
    worker setup error. When the workflow is executed again, all the `reset()`
    steps will be re-computed.

    By default, `reset()` is applied recursively to all dependents of an
    operation.

    Args:
        thing: Operation to reset. If an `types.Artefact` is given, its parent
            operation is `reset()`.
        recursive: If False, only this operation is reset; its dependents are
            untouched. Note that this is dangerous, as it can make
            non-reproducible workflows.
        connection: An explicit Redis connection. Not required if called
            within a `Fun()` context.

    Raises:
        AttributeError:
            when an `types.Artefact` is reset that has status
            `types.ArtefactStatus.const`.
    &#34;&#34;&#34;
    db = get_db(connection)
    if isinstance(thing, Artefact):
        h = thing.parent
        if h == &#34;root&#34;:
            raise AttributeError(&#34;attempted to delete a const artefact.&#34;)
    else:
        h = thing.hash

    # Delete everything from the operation
    op = Operation.grab(db, h)
    for art in op.out.values():
        delete_artefact(db, art)

    if recursive:
        # and its dependencies
        for el in descendants(db, h):
            op = Operation.grab(db, el)
            for art in op.out.values():
                delete_artefact(db, art)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="funsies" href="index.html">funsies</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="funsies.ui.execute" href="#funsies.ui.execute">execute</a></code></li>
<li><code><a title="funsies.ui.shell" href="#funsies.ui.shell">shell</a></code></li>
<li><code><a title="funsies.ui.put" href="#funsies.ui.put">put</a></code></li>
<li><code><a title="funsies.ui.take" href="#funsies.ui.take">take</a></code></li>
<li><code><a title="funsies.ui.takeout" href="#funsies.ui.takeout">takeout</a></code></li>
<li><code><a title="funsies.ui.wait_for" href="#funsies.ui.wait_for">wait_for</a></code></li>
<li><code><a title="funsies.ui.reset" href="#funsies.ui.reset">reset</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>