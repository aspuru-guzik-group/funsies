In `funsies`, workflows written in pure python are saved to
[redis](https://redis.io/), a distributed, in-memory data store. Workflow
execution is performed using the minimal distributed queuing library
[RQ](https://python-rq.org/). Workflows are automatically parallelized and
computed incrementally. Command-line tools are provided that allow funsies to
be easily integrated in pre-existing shell workflows.

Incremental computation and caching are generated by hashing the steps
required to generate all file objects. Workflows are encoded using a [Merkle
tree](https://en.wikipedia.org/wiki/Merkle_tree) data structure, similar to
what is used by [ccache](https://ccache.dev/manual/4.2.html#_how_ccache_works)
for incremental computation or by distributed version control systems such as [mercurial](https://ericsink.com/vcbe/html/repository_structure.html).

Workflows are written in pure python using a set of primitives such as shell
commands (using the `shell()` function) and python glue code (encoded with
`py()`). Errors are handled using a functional programming (a `errors.Result`
monad) inspired by [Rust](https://doc.rust-lang.org/std/result/). In practice,
python code can raise exceptions and shell commands can fail in specifc
branches without compromising the execution of the whole workflow, and the
origin of errors is readily traced.



